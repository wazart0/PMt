import pandas as pd

from libs.db_access.pg_connect import PGconnection
from libs.algorithms.primitive_estimation import ProposeAssigment





def get_default_baseline_id(project_id, cursor):
    get_default_baseline_id = \
        '''
            select default_baseline_id from project where 
            id = '{project_id}';
        '''
    cursor.execute(get_default_baseline_id.format(project_id=project_id))
    return cursor.fetchone()[0]
    

def create_baseline(project_id, cursor):
    create_baseline = \
        '''
            insert into baseline (name, base_project_id) values 
            ('Autogenerated', '{project_id}') 
            returning id;
        '''
    cursor.execute(create_baseline.format(project_id=project_id))
    return cursor.fetchone()[0]





class ProposeTimeline():

    def __init__(self, host='database', user='ad', password='pass', database='pmt', solver = None):

        self.db = PGconnection(host, user, password, database)
        

    def basic_solver(self, project_id, start_date, baseline_id, source_baseline_id):

        partial_update = False
        partial_update_from = '' # some date for partial update

        solver = ProposeAssigment()


        cursor = self.db.connect()

        if source_baseline_id is None:
            source_baseline_id = get_default_baseline_id(project_id, cursor)

        # if baseline_id is None:
        #     baseline_id = create_baseline(project_id, cursor)



        # Get data from DB

        path = './calculate/sql/'

        # TODO those SQLs should be rewritten to python (DB should only provide significant data)
        cursor.execute(open(path + 'temp_projects.sql', 'r').read().
            format(project_id=project_id, source_baseline_id=source_baseline_id)) # TODO create WBS in pandas

        # cursor.execute(open(path + 'calculate_availability.sql', 'r').read().format(start=str(start))) # TODO retrieve only assigned users

        solver.projects = pd.read_sql('select * from projects_in_tree;', self.db.con)
        solver.dependencies = pd.read_sql('select * from projects_dependency;', self.db.con)

        self.db.disconnect()
        return solver

        solver.av = pd.read_sql('select * from availability;', self.db.con)

        solver.ld = pd.read_sql('select * from lowest_level_dependency;', self.db.con) # TODO calculate in pandas

        self.db.disconnect()



        # Calculation part

        solver.initialize()

        from time import time
        algo_time_start = time()
        # finish_date = solver.assign_projects_infinite_resources(baseline.start)
        # finish_date = solver.assign_projects_to_resources_first_free(one_worker_per_project=True)
        # finish_date = solver.assign_projects_by_start_based_on_infinite_resources(one_worker_per_project=True)
        finish_date = solver.assign_projects_by_start_based_on_infinite_resources(partial_update=partial_update, partial_update_from=partial_update_from, one_worker_per_project=True)
        algo_time_finish = time()

        print('Project finish timestamp: ' + str(finish_date))
        print('Calculation time [s]: ' + str(algo_time_finish - algo_time_start))
        print('Unassigned workers time during project: ' + str((solver.av[solver.av.project_id.isnull() & (solver.av.start <= finish_date)].finish - solver.av[solver.av.project_id.isnull() & (solver.av.start <= finish_date)].start).sum()))



        # adjust data to DB

        solver.update_projects()
        solver.projects['baseline_id'] = baseline_id
        solver.projects['llp'] = False
        solver.projects.llp.loc[solver.projects.project_id.isin(solver.lp.project_id)] = True
        solver.projects.worktime_planned = solver.projects.worktime_planned.astype(str) # TODO do we really need to convert?

        solver.ld['baseline_id'] = baseline_id
        solver.ld['llp'] = True
        solver.ld.rename(columns={'dependence': 'timeline_dependency'}, inplace=True)

        solver.dependencies['baseline_id'] = baseline_id
        solver.dependencies['llp'] = False
        solver.dependencies.rename(columns={'dependence': 'timeline_dependency'}, inplace=True)

        solver.av = solver.av[solver.av.project_id.notnull()]
        solver.av.drop(['id'], axis=1, inplace=True)
        solver.av['baseline_id'] = baseline_id
        solver.av['project_id'] = solver.av.project_id.astype(int)



        # insert or update data in DB

        engine = self.db.get_engine()

        # solver.projects.to_sql('baseline_project', engine, index=False, if_exists='append')
        # solver.av.to_sql('baseline_timeline', engine, index=False, if_exists='append')
        # # dependencies probably not needed in new version
        # solver.ld.to_sql('baseline_projectdependency', engine, index=False, if_exists='append')
        # solver.dependencies.to_sql('baseline_projectdependency', engine, index=False, if_exists='append')




