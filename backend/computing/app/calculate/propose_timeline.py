import pandas as pd

from libs.db_access.pg_connect import PGconnection
from libs.algorithms.primitive_estimation import ProposeAssigment
from calculate.expand_calendar import UserCalendarExpander





def get_default_baseline_id(project_id, cursor):
    get_default_baseline_id = \
        '''
            select default_baseline_id from project where 
            id = '{project_id}';
        '''
    cursor.execute(get_default_baseline_id.format(project_id=project_id))
    return cursor.fetchone()[0]
    

def create_baseline(project_id, cursor):
    create_baseline = \
        '''
            insert into baseline (name, base_project_id) values 
            ('Autogenerated', '{project_id}') 
            returning id;
        '''
    cursor.execute(create_baseline.format(project_id=project_id))
    return cursor.fetchone()[0]





class ProposeTimeline():

    def __init__(self, host='database', user='ad', password='pass', database='pmt', solver = None):

        self.db = PGconnection(host, user, password, database)
        

    def basic_solver(self, project_id, start_date, baseline_id, source_baseline_id):

        partial_update = False
        partial_update_from = '' # some date for partial update

        solver = ProposeAssigment()
        expander = UserCalendarExpander(start_date)


        cursor = self.db.connect()

        if source_baseline_id is None:
            source_baseline_id = get_default_baseline_id(project_id, cursor)

        if baseline_id is None: 
            baseline_id = create_baseline(project_id, cursor) # TODO why it doesn't work?
            self.db.con.commit()



        # Get data from DB

        path = './calculate/sql/'

        # TODO those SQLs should be rewritten to python (DB should only provide significant data)
        cursor.execute(open(path + 'temp_projects.sql', 'r').read() \
            .format(project_id=project_id, source_baseline_id=source_baseline_id)) # TODO create WBS in pandas
        cursor.execute(open(path + 'get_calendars_for_users.sql', 'r').read() \
            .format(start_date=start_date)) # TODO retrieve only assigned users


        solver.projects = pd.read_sql('select * from projects_in_tree;', self.db.con)
        solver.dependencies = pd.read_sql('select * from projects_dependency;', self.db.con)
        expander.user_calendar = pd.read_sql('select * from temp_filtered_user_calendar;', self.db.con)
        expander.calendar = pd.read_sql('select * from temp_filtered_calendar;', self.db.con)

        self.db.disconnect()



        # Calculation part

        solver.av = expander.create_availability_frame()
        solver.initialize(start_date)


        from time import time
        algo_time_start = time()
        # finish_date = solver.assign_projects_infinite_resources(baseline.start)
        # finish_date = solver.assign_projects_to_resources_first_free(one_worker_per_project=True)
        # finish_date = solver.assign_projects_by_start_based_on_infinite_resources(one_worker_per_project=True)
        finish_date = solver.assign_projects_by_start_based_on_infinite_resources(partial_update=partial_update, partial_update_from=partial_update_from, one_worker_per_project=True)
        algo_time_finish = time()

        print('Project finish timestamp: ' + str(finish_date))
        print('Calculation time [s]: ' + str(algo_time_finish - algo_time_start))
        print('Unassigned workers time during project: ' + str((solver.av[solver.av.project_id.isnull() & (solver.av.start <= finish_date)].finish - solver.av[solver.av.project_id.isnull() & (solver.av.start <= finish_date)].start).sum()))



        # adjust data to DB

        solver.update_projects()
        solver.projects['baseline_id'] = baseline_id
        solver.projects.worktime = solver.projects.worktime.astype(str) # TODO do we really need to convert?

        solver.dependencies['baseline_id'] = baseline_id
        solver.dependencies.rename(columns={'dependence': 'timeline_dependency'}, inplace=True)

        solver.av['baseline_id'] = baseline_id
        solver.av = solver.av[solver.av.project_id.notnull()]

        
        # TODO lowest level dependency - is that really needed?
        # solver.projects['llp'] = False
        # solver.projects.llp.loc[solver.projects.project_id.isin(solver.lp.project_id)] = True

        # solver.ld['baseline_id'] = baseline_id
        # solver.ld['llp'] = True
        # solver.ld.rename(columns={'dependence': 'timeline_dependency'}, inplace=True)
        
        # solver.dependencies['llp'] = False

        

        # delete and insert data to DB

        engine = self.db.get_engine()

        cursor = self.db.connect()
        cursor.execute('delete from baseline_project where baseline_id = \'' + baseline_id + '\';')
        cursor.execute('delete from baseline_project_assignees_timeline where baseline_id = \'' + baseline_id + '\';')
        cursor.execute('delete from baseline_project_dependency where baseline_id = \'' + baseline_id + '\';')
        self.db.con.commit()
        self.db.disconnect()

        # TODO add drop for given baseline_id
        solver.projects.to_sql('baseline_project', engine, index=False, if_exists='append')
        solver.av.to_sql('baseline_project_assignees_timeline', engine, index=False, if_exists='append')
        solver.dependencies.to_sql('baseline_project_dependency', engine, index=False, if_exists='append')

        # # dependencies probably not needed in new version
        # solver.ld.to_sql('baseline_projectdependency', engine, index=False, if_exists='append')

        return baseline_id




